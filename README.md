# FPGA-Calculator
VHDl code to implement a 4-function calculator using an FPGA.

## Introduction
In the vast scope of digital electronics, there are a variety of ways to practice top-down design and bottom-up implementation. FPGAs are an accessible and useful hardware target on which to apply these techniques, as they can test prototypes quickly while being complex enough to process logic that is greater than glue logic, up to thousands of gates. To efficiently practice and test the design process, one solution was to construct a simple calculator using SCI/UART protocol and datapath logic consistent with that of a three-function calculator in VHDL. 
When beginning the design process, tools such as block diagrams and state machines are helpful in breaking down the larger product into smaller components for efficient simulation and testing. By separating the calculator into an SCI transmitter, receiver, and the calculator operative process, testing and synthesizing the design becomes possible and attractive for efficient verification of implementation. Because the design is synthesis-based, it becomes straightforward to travel through the process from design, modeling, verification, and implementation using the same hardware code in Vivado. Starting with a paper design also allows for a more straightforward coding process, as most of the design can be directly translated into VHDL code from the block diagrams and state machines. 
With this calculator, the idea is to create adding, subtracting, and multiplying functionalities while efficiently utilizing the memory and implementation resources of the FPGA. The main steps discussed in this report are the paper design process, from top-down to lower level diagrams and state machines, the theory of operation of the FPGA calculator, and the construction and testing process. 

##	Design Solution
###	Specification
This calculator is implemented on a Basys-3 FPGA, which is a robust development tool that this design utilizes for synthesis and testing. If this calculator were to be developed for regular use, a smaller board and more functionality would be required to cut down on size and resources whilst creating more efficiency. Within an FPGA, the majority of the hardware and software are implemented inside the chip so the calculator requires less hardware for use. The calculator is able to add, subtract, and multiply numbers that result in a sum, difference, or product that is less than or equal to 999. However, the calculator is not equipped to handle division, non-integer numbers, negative numbers or any other mathematical operations. The calculator takes in sequential key presses from the keyboard attached to the operating computer using an SCI receiver, processes the information in an ASCII to BCD converter, operates on the inputs accordingly, reprocesses the result in a BCD to ASCII converter, and sends out the result using an SCI transmitter. The result is then displayed on the puTTY window of the computer, where the user can then operate on the result once again. 

###	Operating Instructions
To use the FPGA calculator, connect the FPGA to the computer using a USB connection cord. From this step, launch the Vivado code and generate the bitstream so that the hardware code can be loaded into the FPGA. After this, load the device manager to check the port which the FPGA is connected to and launch puTTY on this port.
 After specifying serial transmission in the puTTY window, the calculator is ready to take in inputs â€“ the enter key signals the end of a single input, so it must be pressed between numbers, operations, and following numbers. The calculator will find a result after the equal key is pressed, and from there the user can continue inputting numbers to operate on the result as long as the enter key is pressed after the next operator and the following numerical input. 

###	Theory of Operation
The hardware operates in six separate parts: a clock divider, SCI receiver, ASCII-to-binary converter, calculation operator, binary-to-ASCII converter, and SCI transmitter. The SCI receiver takes in an input from the computer keyboard transmitter. The information then gets sent to the ASCII-BCD calculator, where the operator then performs the action specified, the result returns to a converter to be sent out as ASCII characters by the transmitter to the computer receiver. Within the SCI receiver, the data is put through a double flip-flop to ensure that there are no issues with metastability. Next, the data is loaded into a shift register operated by a baud counter that shifts data in until the appropriate number of bits are reached, and then the data is loaded into the following register in the design.
After the data is processed in the transmitter, it gets sent to the ASCII converter. Here, the converter takes in the eight bit ASCII character and shifts it into a flip-flop so it holds its value while the data is processed. This process also determines the identity of the input character so that it can send the proper information to the operator, whether it needs to calculate a result, store an input number, or handle a concatenated result using an ALU. This uses a lookup table to identify the character. After it is processed, it is sent to the operator.
In the operator, the input is stored in one of two flip-flops depending on when it was sent in, and from this step, the operator uses the information from the converter on if the action should be to add, subtract, or multiply and then uses a multiplexer to combine the two stored numbers in the appropriate manner. This data is then shifted out to another version of the ASCII converter to be sent back to the receiver. The transmitter accepts an eight bit input, which it inputs into a flip-flop to store the data in case another operand is inputted by the user and the current result needs to be updated. From here, the baud count and bit count are enabled and the data is shifted out one bit at a time according to the clock speeds, until all bits are shifted out. The operator is enabled when a value is detected from the ASCII converted. From this, the baud count is started and the operator waits for an operand to be entered, otherwise it replaces the stored number with the new input. If it detects an operand, it waits for another numerical input and once that is detected, it creates a new calculation. This calculation is stored until the user decides to modify the result with another calculation or begin a new operation.
The conversion logic is as follows: when an input or output is detected, the converter uses the LUT to find the address of the ASCII character, waits until the transmitter or receiver is ready, and then sends the proper binary values one bit at a time. It repeats this cycle for each three digits, as the LUTs use values 000 through 999, until each place value of the input is accounted for.
The logic of the transmitter is similar to that of the receiver, in that it is enabled when new data is entered and shifts the data out until the number of bits reaches the specified terminal count.

## Construction
After completing and finalizing the block diagrams and state machines, the next step in the design process was to write and simulate the paper design into VHDL code. This project can be done remotely using EDA playground or the Vivado application on the Thayer shares, but the first step was to write the hardware code for each module and test them individually. To do this, we first created VHDL files for the SCI receiver (Figure 7.23), the SCI transmitter (Figure 7.22), and the calculator operation process (Figure 7.24). Once the code is written and reviewed, testbenches can be created to simulate the inputs from the computer for the receiver, a BCD digit entries into the operator, and the calculated output to the transmitte. After the modular code functioned in simulation, we were able to move onto the process of creating a top-level file, a constraints file, and a .coe file for the ROM memory to be able to convert inputs from ASCII-BCD or BCD-ASCII. 
Once we connected the files in a top-level shell, we were able to move onto creating the
constraints file, which just enables the Rx and Tx ports on the Basys-3 board (Figure 7.26). After this, we wrote a testbench to ensure that the receiver, operator, and transmitter were working together (Figure 7.27-7.29). Moving on to the .coe file, we modified existing MATLAB code (Figure 7) to create a .coe file containing three digit numbers, 000 through 999. These represent the valid inputs and outputs that the calculator can handle. Finally, we connected the BCD-ASCII conversion processes to the top-level to test the full functionality in simulation, for which we modified the testbench slightly to eliminate unnecessary intermediate values. 
	The debugging process was lengthy and convoluted for us, as we wrote our modules slightly larger than they should have been for maximum efficiency. Inconsistencies in the counters in the receiver and transmitter led to many difficult bugs to fix, and facilitating the connection between the BCI-ASCII converter process and the operator required more debugging and wiring than anticipated. The testbench and simulation proved to be extremely useful for debugging, as many errors occurred due to clock count delays between the elements of the calculator and they are easily spotted when utilizing the signals in the Vivado simulation.

Credit to partner, Kathy Cui.


